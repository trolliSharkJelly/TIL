# 토큰 기반 인증(Token-based Authentication)

## 토큰 기반 인증은 왜, 그리고 언제 쓸까?

세션 기반 인증은 서버 또는 DB에 유저의 정보를 담는 인증 방식이다.  
서버에서는 유저가 민감한 정보를 요청할 때마다 유저에게 요청에 대한 응답을 해도 괜찮은지 확인하기 위해 클라이언트가 보낸 세션 id를 가지고 있는 세션 객체와 비교한다.  
매 요청마다 서버 또는 DB를 찾는게 불편하고, 그에 따른 리소스에 대한 부담을 덜고 싶다면 어떤 방법이 있을까? 토큰 기반 인증 중 가장 대표적인 JWT(JSON Web Token)에 대해 알아보자.

---

## 클라이언트에 인증 정보 보관하기

토큰은 무엇일까?

- 대중교통 토큰
- 오락실 토큰
- 북 토큰(책 교환 상품권 또는 바우처)

위 토큰들은 공통적으로 "나는 돈을 지불했고, 이 서비스를 이용할 수 있다"는 메세지를 담고 있다.

이러한 개념에 착안하여 인증 정보를 보관하는 방법으로 토큰 기반 인증이 고안되었다. 이런 토큰은 클라이언트에 저장되는데 이는 잘 알려진 XSS, CSRF 공격에 노출될 위험이 있다. 민감한 정보는 클라이언트에 담으면 안 되는데, 인증과 관련된 토큰을 클라이언트에 왜 담는가? 라는 의문이 들 수 있다.  
하지만 토큰은 유저 정보를 암호화하기 때문에 클라이언트에 담을 수 있다.

---

## JWT의 종류

JWT는 보통 다음과 같이 두 가지 종류의 토큰을 이용해 인증을 구현한다.

1. 액세스 토큰(Access Token)
2. 리프레시 토큰(Refresh Token)

액세스 토큰은 보호된 정보들(유저의 이메일, 연락처 등)에 접근할 수 있는 **권한부여**에 사용한다. 클라이언트가 처음 인증을 받게 될 때(로그인 시) 액세스 토큰, 리프레시 토큰 두 가지를 다 받지만 실제로 권한을 얻는데 사용하는 토큰은 액세스 토큰이다.

```plain
그럼 액세스 토큰만 있으면 되지 않을까?
```

**권한을 부여 받는 데**엔 액세스 토큰만 가지고 있으면 된다.  
하지만 액세스 토큰을 악의적인 유저가 얻었다면 자신이 OO유저인냥 서버에 여러 요청을 보낼 수 있다.  
그렇기 때문에 액세스 토큰에는 비교적 짧은 유효기간을 주어 토큰을 탈취하더라도 오랫동안 사용할 수 없게 하는 것이 좋다.

```plain
리프레시 토큰도 탈취 당한다면?
```

유효기간이 긴 리프레시 토큰도 악의적인 유저가 탈취한다면 문제가 발생할 수 있다. 그래서 유저의 편의보다 **정보를 지키는 것이 더 중요한** 웹사이트들은 리프레시 토큰을 사용하지 않는 곳이 많다.  
각 방법들의 장단점을 참고하여 필요에 맞게 사용하는 것이 좋다.

---

## JWT 구조

JWT는 Header, Payload, Signature로 이뤄져 있다.

1. Header  
   이것이 어떤 종류의 토큰인지, 어떤 알고리즘으로 시그니처를 sign(암호화)할 지 적혀져 있다.  
   JSON 형태로 정보가 담겨있다.  
   아래의 객체를 base64 방식으로 인코딩하면 JWT의 첫 번째 부분인 Header가 완성된다.

```javascript
{
    "alg": "HS256",
    "typ": "JWT"
}
```

2. Payload  
   단어 그대로 서버에서 활용할 수 있는 유저의 정보가 담겨 있다.  
   어떤 정보에 접근 가능한지에 대한 권한, 유저의 이름과 같은 개인정보 등을 담을 수 있지만 너무 민감한 정보는 담지 않는 것이 좋다. 디코딩이 쉬운 base64 방식으로 인코딩 되기 때문이다.

```javascript
{
    "sub": "someInformation",
    "name": "jelly",
    "phone": "010-1111-2222"
}
```

3. Signature  
   base64로 인코딩 된 Header, Payload를 서버의 비밀 키(암호화에 추가할 salt)와 헤더에서 지정한 알고리즘을 이용해 암호화한다.  
   base64 인코딩은 누구나 쉽게 디코딩 할 수 있어 Header, Payload 모두 쉽게 확인할 수 있지만 비밀키를 사용해 이를 암호화한 값(Signature)은 비밀키를 보유한게 아니라면 해독하는데 시간과 노력이 들어간다.  
   예를 들어 HMAC SHA256 알고리즘을 사용한다면 Signature는 아래와 같은 방식으로 생성된다.

```javascript
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret);
```

누군가 권한을 속이기 위해 payload를 변조하여 base64로 인코딩하더라도 원본 payload로 암호화한 시그니처 값과 다르기 때문에 서버가 해당 토큰이 변조되었음을 확인할 수 있다.

---

## 토큰 기반 인증 절차. 

![스크린샷 2022-07-15 오후 9 46 54](https://user-images.githubusercontent.com/99730280/179225808-7e751f7e-b9f4-4976-8d8b-7498eb1e6bef.png)

---

## 토큰 기반 인증의 장점

1. Statelessness & Scalability(무상태성, 확장성)

- 서버는 클라이언트에 대한 정보를 저장할 필요가 없다(토큰이 해독되는지만 판단한다)
- 클라이언트는 새로운 요청을 보낼 때마다 토큰을 헤더에 포함시키면 된다. 서버를 여러개 가지고 있는 서비스라면 큰 장점이 된다. 같은 토큰으로 여러 서버에서 인증이 가능하기 때문이다.

2. 안전성

- 암호화된 토큰을 사용하고, 암호화 키를 노출할 필요가 없다.

3. 어디서나 생성 가능하다.

- 토큰을 확인하는 서버가 토큰을 만들지 않아도 된다.
- 토큰 생성용 서버를 만들거나, 다른 회사에게 토큰 관련 작업을 맡기는 것등 다양한 활용이 가능하다.

4. 권한 부여에 용이하다

- 토큰의 payload(내용물) 안에 어떤 정보에 접근 가능한 지 정할 수 있다. 예를 들어 서비스의 특정 목록(연락처 또는 사진)에만 접근할 수 있도록 사용 권한을 부여할 수 있다.
