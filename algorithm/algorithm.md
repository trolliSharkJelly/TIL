# Algorithm
- 문제를 해결하는 최선의 선택
- 어떤 문제를 해결하기 위한 여러 동작들의 모임

## 1. Algorithm
### 1-1. 알고리즘이란?
- 어떤 문제를 해결하기 위해 일련의 절차를 정의하고, 공식화한 형태로 표현한 일종의 문제 풀이 방법
- 프로그래밍에서는 input 값을 통해 output 값을 얻기 위한 계간 과정
- 일련의 절차를 정의하고 공식화만 시킨다고 전부 알고리즘은 아니며, 일정한 조건들을 반드시 만족해야 한다.
```
전자렌지에 음식을 데우기 위해 치킨을 넣었다.
동작 시간은 7분이며 7분 후에는 END 메세지가 표시될 것이다.
7분이 지나고 전자렌지에 표시된 숫자는 초당 1초씩 줄어든다.
총 420번의 숫자가 바뀐 전자렌지는 동작을 종료한다.
```
#### 1) 입력(Input)  
알고리즘은 출력에 필요한 자료를 입력받을 수 있어야 한다.  
전자렌지는 7분이라는 시간을 입력 받아야 한다.  
전자렌지는 시간을 입력 받아야 동작하지만 꼭 입력을 받지 않아도 되는 알고리즘이 있다
(예시 : 원주율의 100번째 자리 수를 구하는 경우, 입력은 없지만 출력은 있다).

#### 2) 출력(Output)  
알고리즘은 실행이 되면 적어도 한 가지 이상의 결과를 반드시 출력해야 한다.  
만약 알고리즘에 출력이 없다면 이 알고리즘은 끝이 났는지 확인할 수 없기 때문이다.  
출력은 알고리즘이 끝이 났다는 표현이므로 반드시 존재해야하며, 유한성과 연관이 있다.  
해당 예시는 전자렌지에 'END 메세지'가 표시 되는 것과 관련이 있다.

#### 3) 유한성(Finiteness)  
알고리즘은 유한한 명령어를 수행한 후 유한한 시간 내에 종료해야 한다.  
알고리즘은 실행 후 반드시 종료해야 한다.  
알고리즘이 무한하게 실행된다면 출력의 기약이 없을 것이다. 
전자렌지가 멈추지 않고 계속 동작한다면 그 전자렌지는 정상이 아니다.

#### 4) 명확성(Definiteness)  
알고리즘의 각 단계는 단순하고 명확해야 한다.  
전자렌지가 몇 분 뒤에 동작이 완료된다면 명확하지 않고 모호하므로 "7분 뒤에 END 메세지가 나타나고 종료됩니다"
라고 명확하게 표현되어야 한다.

#### 5) 효율성(Effciency)  
알고리즘은 가능한 효율적이어야 한다. 모든 과정은 명백하게 실행 가능해야 하며, 실행 가능성이 떨어지는 알고리즘은
효율적이지 못한 알고리즘이다. 시간 복잡도와 공간 복잡도가 낮을 수록 효율적인 알고리즘이라 볼 수 있다.

### 1-2. 알고리즘 문제는 어떻게 해야 잘 풀 수 있을까?
#### 1) 문제 이해하기
문제 설명, 입출력, 주의사항 등을 바탕으로 문제가 무엇인지 이해한다.

#### 2) 문제 해결을 위한 전략 세우기
코드 작성 전 수도 코드를 작성한다.

#### 3) 문제를 코드로 옮겨보기
수도 코드를 코드로 옮기며 최적화를 시도한다.

## 2, 시간 복잡도(알고리즘의 시간 효율성)
![스크린샷 2022-08-10 오후 9 44 51](https://user-images.githubusercontent.com/99730280/183904453-0c687d98-70d9-4503-bc7b-6288191fa9c2.png)

문제를 해결하기 위해 코드 작성 시 시간 복잡도를 고려한다는 것은 아래와 같다.
**입력값의 변화에 따라 연산을 실행할 때, 연산 횟수에 비해 시간이 얼마만큼 걸리는가?**
효율적인 알고리즘을 구현한다는 것은 입력값이 커짐에 따라 증가하는 시간의 비율을 최소화한 알고리즘을 구성하는 것이다. 그리고 이 시간 복잡도는 주로 빅-오 표기법을 사용해 나타낸다

### Big-O 표기법
시간 복잡도를 표기하는 방법은 `Big-O (빅-오)`, `Big-Ω (빅-오메가)`, `Big-θ (빅-세타)`가 있다.  
위 세 가지 표기법은 시간 복잡도를 각각 최악, 최선, 중간(평균)에 대하여 나타내는 방법이다.   
이 중에서 Big-O 표기법이 가장 자주 사용된다.  

빅오 표기법은 최악의 경우를 고려하므로, 프로그램이 실행되는 과정에서 소요되는 최악의 시간까지 고려할 수 있기 때문이다.
빅-오 표기법은 "이 정도 시간까지 걸릴 수 있다"를 고려해야 그에 맞는 대응이 가능하다.  

알고리즘의 결과를 반환하는데 최선의 경우 1분, 평균적으로 5분, 최악의 경우 5시간이 걸리는 알고리즘을 구현했으며, 개발자는 최선의 경우를 고려한다고 가정하자.  
해당 알고리즘을 10번 실행 시 최선의 경우를 고려한다면 10분이 걸리는것이 맞지만 5시간이 걸렸다면 **어디서 문제가 발생했는가**라는 의문이 생길 것이다.  
최선의 경우를 생각했으니 문제점을 알아내기 위해 로직을 다시 파악해야 하므로 문제 파악에 시간이 요구된다.  

평균값과 관련된 시간복잡도를 고려했다면, 알고리즘을 10번 실행 시 50분의 시간이 소요되어야 하지만 5시간이 걸렸다면 최선의 경우에서 고려했을 당시 했던 고민을 다시 할 수 있다.  
위의 경우보다 최악의 경우를 대비하는 것이 바람직하며, 따라서 다른 표기법보다 Big-O 표기법을 많이 사용한다.

### O(1), constant complexity
- O(1)은 constant complexity라고 하며, 입력 값이 증가하더라도 시간이 늘어나지 않는다. 즉, 입력 값의 크기와 관계 없이 즉시 출력값을 얻을 수 있다는 의미이다. 
- O(1)의 시간 복잡도를 가진 알고리즘 예시  
입력 값의 크기가 아무리 커져도 즉시 출력값을 얻어낼 수 있다. 배열의 길이가 100이 넘어도 즉시 해당 index에 접근해 값을 반환할 수 있다.
```javascript
function O_1_algorithm(arr, index) {
	return arr[index];
}

let arr = [1, 2, 3, 4, 5];
let index = 1;
let result = O_1_algorithm(arr, index);
console.log(result); // 2
```

### O(n)
- O(n)은 linear complexity라고 하며, 입력값이 증가함에 따라 시간 또한 같은 비율로 증가하는 것을 의미한다.
- 예를 들어 입력 값이 1일 때 1초의 시간이 걸리고, 입력값을 100배 증가시켰을 때 1초의 100배인 100초가 걸리는 알고리즘을 구현했다면, 그 알고리즘은 O(n)의 시간 복잡도를 가진다고 할 수 있다.
- O(n)의 시간 복잡도를 가진 알고리즘의 예시  
O_n_algorithm, another_O_n_alghrithm 함수에서 입력값(n)이 1씩 증가할 때마다 코드의 실행 시간이 1초씩 증가한다.  
이것을 보고 해당 알고리즘은 O(2n)이라고 생각할 수 있지만 Big-O 표기법으로는 O(n)으로 표기한다.   
입력값이 커질 수록 계수의 의미가 퇴색되기 때문에 같은 비율로 증가하고 있다면 2배가 아닌 3배, 5배로 증가하더라고 O(n)으로 표기한다.
```javascript
function O_n_algorithm(n) {
	for(let i = 0; i < n; i++) {
		// ...
	}
}

function another_O_n_algorithm(n) {
	for(let i = 0; i < n; i++) {
		// ...
	}
}

```

### O(log n)
- logarithmic complexity라고 부르며, Big-O 표기법 중 O(1) 다음으로 빠른 시간 복잡도를 가진다.
- BST(Binary Search Tree)에서 원하는 값 탐색 시 노드를 이동할 때마다 경우의 수가 절반으로 줄어든다. 숫자를 제시할 때마다 경우의 수가 절반이 줄어들기 때문에 최악의 경우에도 7번이면 원하는 숫자를 찾을 수 있게 된다. 

### O(n²)
- quadratic complexity라고 부르며, 입력값이 증가함에 따라 시간이 n의 제곱수의 비율로 증가하는 것을 의미한다.
- 예를 들어 입력값이 1일 경우 1초가 걸리던 알고리즘에 5라는 값을 주었더니 25초가 걸리게 되면 이 알고리즘의 시간 복잡도는 O(n²)이다.
- O(n²)의 시간 복잡도를 가진 알고리즘
```javascript
function O_quadratic_algorithm(n) {
	for(let i = 0; i < n; i++) {
		for(let j = 0; j < n; j++) {
			// ...
		}
	}
}

function another_O_quadratic_algorithm(n) {
	for(let i = 0; i < n; i++) {
		for(let j = 0; j < n; j++) {
			for(let k = 0; k < n; k++) {
				// ...
			}
		}
	}
}

```

### O(2^n)
- exponential complexity라고 부르며 Big-O 표기법 중 가장 느린 시간 복잡도를 가진다.
- 구현한 알고리즘의 시간 복잡도가 O(2^n)이라면 다른 접근 방식을 고민하는 것이 좋다.
- 재귀로 구현하는 피보나치 수열은 O(2^n)의 시간복잡도를 가진 대표적인 알고리즘이며, 브라우저 개발자 창에서 n을 40으로 두어도 수초가 걸리는 것을 확인할 수 있고, n이 100 이상이면 평생 결과를 반환받지 못할 수도 있다.
```javascript
function fibonacci(n) {
	if(n <= 1) {
		return 1;
	}
	return fibonacci(n - 1) + fibonacci(n - 2);
}
````

### 데이터 크기에 따른 시간 복잡도
일반저그로 코딩 테스트 문제를 풀 때는 정확한 값을 제한된 시간 내에 반환하는 프로그램을 작성해야 한다.  
컴퓨터의 사양에 따라 차이는 있겠지만, 시간 제한과 주어진 데이터 크기 제한에 따른 시간 복잡도를 예측하는 것은 중요하다.  

예를 들어 입력으로 주어지는 데이터에는 n만큼의 크기를 가지는 데이터가 있고, n이 1,000,000보다 작은 수일 때 O(n) 혹은 (nlogn)의 시간 복잡도를 가지도록 예측하여 프로그램을 작성할 수 있다.
여기서 n^2의 시간 복잡도는 예측할 수가 없기 때문이다.
주어진 데이터가 작을 때는 시간 복잡도가 크더라도 문제를 풀어내는 것에 집중하자.

대략적인 데이터 크기에 따른 시간 복잡도는
|데이터 크기 제한|예상되는 시간 복잡도|
|---|---|
|n <= 1,000,000|O(n) or O(logn)|
|n <= 10,000|O(n^2)|
|n <= 500|O(n^3)|

## 2.공간 복잡도(알고리즘의 공간(메모리)효율성)
- 알고리즘이 수행되는데 필요한 메모리의 총량
- 프로그램이 필요로 하는 메모리 공간을 산출하는 것
- 프로그램이 요구하는 공간은 고정적인 공간과 함께 가변적인 공간을 함께 요구하는데, 가변 적인 공간에 집중해야 한다. 왜냐하면 고정적인 공간은 처리할 데이터의 양에 무관하게 항상 요구되는 공간으로써, 프로그램 성능에 큰 영향을 주지 않지만 가변적인 공간은 처리할 데이터의 양에 따라 다르게 요구되는 공간으로써 프로그램의 성능에 큰 영향을 준다.

### 공간 복잡도 예시
함수 factorial은 재귀함수로 구현되었다. 변수 n에 따라 변수 n이 n개가 만들어지게 되며 factorial 함수를 재귀함수로 1까지 호출할 경우 n부터 1까지 스택에 쌓이게 된다. 따라서 해당 함수의 공간 복잡도는 O(n)이라고 할 수 있다.
```javascript
function factorial(n) {
	if(n === 1) {
		return n;
	}

	return n * factorial(n - 1);
}
```

### 공간복잡도의 중요성
보통 때의 공간 복잡도는 시간 복잡도보다 중요성이 떨어진다.
왜냐하면 시간이 적으면서 메모리까지 지수적으로 증가하는 경우는 거의 없으며 시간 내에 발생하는 메모리 문제들은 보통 알고리즘을 구현할 때 발생하는 문제이기 때문이다.  

보통 시간 복잡도에 맞다면 공간 복잡도도 얼추 통과하기 때문에 알고리즘 구현 시 공간 복잡도에 실패해다면, 보통은 변수를 설정할 때 쓸데없는 공간을 많이 차지하도록 설정했을 경우가 많을 것이니 그것부터 확인해야 한다.  

그러나 때에 따라 공간 복잡도를 중요하게 보는 경우가 있는데 동적 계획법과 같은 알고리즘이나 하드웨어 환경이 매우 한정되어 있는 경우가 그 경우이다. 동적 계획법은 알고리즘 자체가 구현 시 메모리를 많이 요구하기 때문에 입력 값의 범위가 넓어지면 사용하지 못하는 경우도 만혹, 하드웨어 환경이 매우 한정되어 있는 경우라면 가용 메모리가 제한되어 있기 때문이다

## 느낀점
부트캠프에서 매일 아침 알고리즘 문제를 풀 수 있게 제공해주는데, 나는 알고리즘 문제에 관심이 없어서 문제 푸는 시간에 다른 것을 더 많이 공부했다. 그러나 오늘 알고리즘을 공부하며 필요성을 느끼게 되었다.  
프론트엔드 개발자를 준비하면서 시각적으로 보이는 부분에 대한 고민이 많았지만, 코드에 시간 복잡도를 고려하지 않는다면 내가 만드는 서비스는 보기 좋은 떡에 불과할 수 있다는 사실을 깨달았다.  
알고리즘을 공부하고 문제를 풀어봤을 때 내가 생각한 해결 과정을 코드로 구현하는건 많은 시간이 걸렸고, 잘 알고 있다고 생각한 문법도 코드에 적용되지 않는 문제점이 생겨 곤란한 상황이 많았다.
다음주면 프로젝트 기간이 되는데 알고리즘을 공부하면서 부족한 부분을 많이 느껴 어디서부터 공부할지 막막하기도 하다. 예전부터 풀지 못한 알고리즘 문제를 하루에 1회씩 풀고 고민하는 시간을 가져보며 조금씩 프로젝트에 대비해야겠다.

