# Tree

## 정의
- 나무를 거꾸로 뒤집어 놓은 듯한 모습이며, 그래프의 여러 구조 중 단방향 그래프의 한 구조로 노드들이 나무 가지처럼 연결된 비선형 자료구조.

## 구조와 특징 
<img width="789" alt="스크린샷 2022-08-16 오후 11 25 25" src="https://user-images.githubusercontent.com/99730280/184904416-4f7f68fb-88c7-49d8-b406-a8daa11abe6c.png">
루트(Root)라는 하나의 데이터를 시작으로 여러 개의 데이터를 간선(edge)로 연결한다.  
각 데이터를 노드(Node)라고 하며 두 개의 노드가 상하 계층으로 연결되면 부모/자식 관계를 가진다.  

- 깊이(depth) : 루트로부터 하위 계층의 특정 노드까지의 깊이. 루트 A의 깊이는 0이며, B와 C의 깊이는 1이다.
- 레벨(Level) : 같은 깊이를 가지고 있는 노드. depth가 0인 루트 A의 level은 1이고, depth가 1인 B와 C의 level은 2이다.
- 높이(Height) : 리프 노드를 기준으로 루트까지의 높이. 리프 노드와 직간접적으로 연결된 노드의 높이를 표현하며, 부모 노드는 자식 노드의 가장 높은 height 값에 +1한 값을 높이로 가진다. 트리 구조의 높이 표현 시 각 리프 노드의 높이를 0으로 놓는다. H, I, E, F, J의 높이는 0이고, D와 G의 높이는 1이다. B의 높이는 2인데 `D의 height + 1`을 높이로 가진다. 루트 A의 높이는 3이다.
- 서브 트리(Sub tree) : 트리 구조의 root에서 뻗어 나오는 큰 트리의 내부에, 트리 구조를 갖춘 작은 트리. 

## 용어 정리
- 노드(Node) : 트리 구조를 이루는 모든 개별 데이터
- 루트(Root) : 트리 구조의 시작점이 되는 노드
- 부모 노드(Parent node) : 두 노드가 상하관계로 연결되어 있을 때 상대적으로 루트에서 가까운 노드
- 자식 노드(Child node) : 두 노드가 상하관계로 연결되어 있을 때 상대적으로 루트에서 먼 노드
- 리프(Leaf) : 트리 구조의 끝 지점이고, 자식 노드가 없는 노드

## Tree의 실사용 예제
- 컴퓨터의 디렉토리 구조 : 어떤 파일을 찾을 때 바탕화면 폴더에서다른 폴더로 이동하고 또 그 안에서 다른 폴더로 이동하면서 원하는 파일을 찾는다. 
모든 폴더는 루트폴더에서 시작되며, 가지를 뻗는 모양을 띈다.

## 이진 트리(Binary tree)
- 자식 노드가 최대 두 개인 노드들로 구성된 트리
- 두 개의 자식 노드는 왼쪽 자식 노드와 오른쪽 자식 노드로 나눌 수 있다.
- 이진 트리는 자료의 삽입, 삭제 방법에 따라 정 이진 트리(Full binary tree), 완전 이진 트리(Complete binary tree), 포화 이진 트리(Perfect binary tree)로 나눈다.

### 이진 트리 특징
- 정 이진 트리(Full binary tree) : 각 노드가 0개 혹은 2개의 자식 노드를 갖는 트리.
- 포화 이진 트리(Perfect binary tree) : 정 이진 트리이면서 완전 이진 트리. 모든 리프 노드의 레벨이 동일하고, 모든 레벨이 가득 채워져 있는 트리.
- 완전 이진 트리(Complete binary tree) : 마지막 레벨을 제외한 모든 노드가 가득 차 있어야 하고, 마지막 레벨의 노드는 전부 차 있지 않아도 되지만 왼쪽이 채워져야 한다.  

## 이진 탐색 트리(Binary Search Tree)
이진 탐색 트리란 이진 탐색(binary search)과 연결 리스트(linked list)를 결합한 이진트리이다.  
이진 탐색의 효율적인 탐색 능력을 유지하면서도, 빈번한 자료 입력과 삭제를 가능하게끔 고안됐다.  

### 이진 탐색 트리의 특징
- 각 노드에 중복되지 않는 키(Key)가 있다.
- 루트노드의 왼쪽 서브 트리는 해당 노드의 키보다 작은 키를 갖는 노드들로 이루어져 있다.
- 루트노드의 오른쪽 서브 트리는 해당 노드의 키보다 큰 키를 갖는 노드들로 이루어져 있다.
- 좌우 서브트리도 모두 이진 탐색 트리여야 한다.
- 이진 탐색 트리(Binary Search Tree)는 모든 왼쪽 자식의 값이 루트나 부모보다 작고, 모든 오른쪽 자식의 값이 루트나 부모보다 큰 값을 가진다.  

아래는 이진 탐색 트리의 예시이다.  
이진 탐색 트리는 균형 잡힌 트리가 아닐 때, 입력되는 값의 순서에 따라 한쪽으로 노드들이 몰리게 될 수 있다.  
균형이 잡히지 않은 트리는 탐색하는 데 시간이 더 걸리는 경우도 있기 때문에 해결하기 위해
삽입과 삭제마다 트리의 구조를 재조정하는 과정을 거치는 알고리즘을 추가할 수 있다.  
<img width="530" alt="스크린샷 2022-08-16 오후 11 25 47" src="https://user-images.githubusercontent.com/99730280/184904484-7ae974b8-de5f-4cca-9c87-fd14ef92a398.png">

- 이진 탐색 트리는 기존 이진 트리보다 탐색이 빠르다는 장점이 있다. 이진 탐색 트리의 연산은 트리의 높이가 h(height)라면 o(h)의 복잡도를 가지게 되는데 이와 같은 효율적인 연산이 가능한 이유는 탐색 과정에 있다. 이진 탐색 트리의 탐색 과정은 아래와 같다.
1. 루트 노드의 키와 찾고자 하는 값을 비교한다. 만약 찾고자 하는 값이라면 탐색을 종료한다.
2. 찾고자 하는 값이 루트 노드의 키보다 작다면 왼쪽 서브 트리로 탐색을 진행한다.
3. 찾고자 하는 값이 루트 노드의 키보다 크다면 오른쪽 서브 트리로 탐색을 진행한다.

이 과정을 찾고자 하는 값을 찾을 때까지 반복해 진행하며, 만약 값을 찾지 못한다면 그대로 연산을 종료하게 된다. 이러한 탐색 과정을 거치면 최대 트리의 높이(h)만큼 탐색을 진행한다. 여기서 알아둬야 할 점은 트리 안에 찾으려는 값이 없더라도 최대 h번의 연산 및 탐색이 진행된다.
